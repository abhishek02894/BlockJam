using UnityEngine;
using UnityEditor;
using System.IO;
using System.Text;
using System.Collections.Generic;
using System.Linq;

namespace Tag.Block.Editor
{
    public class IdCodeGenerator : AssetPostprocessor
    {
        private const string GeneratedCodePath = "Assets/Scripts/Utilities/Generated/";
        private const string GeneratedNamespace = "Tag.NutSort";
        private const string MainClassName = "GeneratedCodeIds";
        private const string OutputFileName = MainClassName + ".cs";

        private static readonly Dictionary<string, string> MappingAssets = new Dictionary<string, string>()
        {
            { EditorConstant.MAPPING_IDS_PATH + "/BoosterIdMappings.asset", "BoosterIDs" },
            { EditorConstant.MAPPING_IDS_PATH + "/CurrencyIdMappings.asset", "CurrencyIDs" },
            { EditorConstant.MAPPING_IDS_PATH + "/NutColorIdMappings.asset", "NutColorIds" },
            { EditorConstant.MAPPING_IDS_PATH + "/NutTypeIdMappings.asset", "NutTypeIds" },
            { EditorConstant.MAPPING_IDS_PATH + "/ScrewTypeIdMappings.asset", "ScrewTypeIds" },
        };

        private static void OnPostprocessAllAssets(string[] importedAssets, string[] deletedAssets, string[] movedAssets, string[] movedFromAssetPaths)
        {
            bool shouldGenerate = false;

            foreach (string importedAssetPath in importedAssets)
            {
                if (MappingAssets.ContainsKey(importedAssetPath))
                {
                    shouldGenerate = true;
                    break;
                }
            }

            if (!shouldGenerate)
            {
                foreach (string deletedAssetPath in deletedAssets)
                {
                    if (MappingAssets.ContainsKey(deletedAssetPath))
                    {
                        shouldGenerate = true;
                        break;
                    }
                }
            }

            if (!shouldGenerate)
            {
                foreach (string movedAssetPath in movedAssets)
                {
                    if (MappingAssets.ContainsKey(movedAssetPath))
                    {
                        shouldGenerate = true;
                        break;
                    }
                }
            }

            if (shouldGenerate)
            {
                GenerateAllIdConstants();
            }
        }

        private static void GenerateAllIdConstants()
        {
            Debug.Log($"[IdCodeGenerator] Generating combined ID constants file: {OutputFileName}");

            StringBuilder sb = new StringBuilder();
            sb.AppendLine("// This file is auto-generated by IdCodeGenerator.cs");
            sb.AppendLine("// Do not modify this file manually.");
            sb.AppendLine();
            sb.AppendLine("namespace " + GeneratedNamespace);
            sb.AppendLine("{");
            sb.AppendLine($"\tpublic static class {MainClassName}");
            sb.AppendLine("\t{");
            sb.AppendLine("\t\t// Nested static classes for different ID types");
            sb.AppendLine();

            foreach (var mappingEntry in MappingAssets)
            {
                string configAssetPath = mappingEntry.Key;
                string nestedClassName = mappingEntry.Value;

                if (string.IsNullOrWhiteSpace(nestedClassName) || !System.CodeDom.Compiler.CodeGenerator.IsValidLanguageIndependentIdentifier(nestedClassName))
                {
                    Debug.LogError($"[IdCodeGenerator] Invalid nested class name '{nestedClassName}' for asset '{configAssetPath}'. Skipping this mapping type.");
                    continue;
                }

                BaseIDMappingConfig config = AssetDatabase.LoadAssetAtPath<BaseIDMappingConfig>(configAssetPath);

                sb.AppendLine($"\t\tpublic static class {nestedClassName}"); // Start nested class
                sb.AppendLine("\t\t{");

                if (config == null)
                {
                    Debug.LogWarning($"[IdCodeGenerator] Mapping config asset not found at path: {configAssetPath}. The nested class '{nestedClassName}' will be empty.");
                    sb.AppendLine("\t\t\t// Associated config asset not found.");
                }
                else if (config.idMapping == null || config.idMapping.Count == 0)
                {
                    Debug.LogWarning($"[IdCodeGenerator] Mapping config asset at path '{configAssetPath}' is empty. The nested class '{nestedClassName}' will be empty.");
                    sb.AppendLine("\t\t\t// Associated config asset is empty.");
                }
                else
                {
                    HashSet<string> nestedGeneratedIdentifiers = new HashSet<string>();

                    var sortedMappings = config.idMapping.OrderBy(pair => pair.Key);

                    foreach (var pair in sortedMappings)
                    {
                        string originalName = pair.Value;
                        int id = pair.Key;

                        string identifier = SanitizeIdentifier(originalName);

                        if (string.IsNullOrWhiteSpace(identifier))
                        {
                            Debug.LogError($"[IdCodeGenerator] Skipping entry with ID {id} from '{configAssetPath}' because its name '{originalName}' resulted in an empty identifier after sanitization.");
                            continue;
                        }

                        if (nestedGeneratedIdentifiers.Contains(identifier))
                        {
                            Debug.LogError($"[IdCodeGenerator] Skipping entry with ID {id} and name '{originalName}' from '{configAssetPath}' because its sanitized identifier '{identifier}' is a duplicate *within* the '{nestedClassName}' group.");
                            continue;
                        }

                        sb.AppendLine($"\t\t\tpublic const int {identifier} = {id};");
                        nestedGeneratedIdentifiers.Add(identifier);
                    }
                }


                sb.AppendLine("\t\t}");
                sb.AppendLine();
            }


            sb.AppendLine("\t}");
            sb.AppendLine("}");

            string fullOutputPath = Path.Combine(GeneratedCodePath, OutputFileName);

            string outputDir = Path.GetDirectoryName(fullOutputPath);
            if (!Directory.Exists(outputDir))
            {
                Directory.CreateDirectory(outputDir);
            }

            try
            {
                File.WriteAllText(fullOutputPath, sb.ToString());
                Debug.Log($"[IdCodeGenerator] Successfully generated {OutputFileName} at {fullOutputPath}");
            }
            catch (System.Exception e)
            {
                Debug.LogError($"[IdCodeGenerator] Failed to write generated code file to {fullOutputPath}: {e.Message}");
            }
        }

        private static string SanitizeIdentifier(string name)
        {
            if (string.IsNullOrWhiteSpace(name)) return "";

            StringBuilder sb = new StringBuilder();
            bool firstChar = true;

            foreach (char c in name)
            {
                if (char.IsLetterOrDigit(c) || (firstChar && c == '_'))
                {
                    sb.Append(c);
                    firstChar = false;
                }
                else if (!firstChar) //
                {
                    sb.Append('_');
                }
            }

            string identifier = sb.ToString();

            if (!string.IsNullOrEmpty(identifier) && !char.IsLetter(identifier[0]) && identifier[0] != '_')
            {
                identifier = "_" + identifier;
            }

            identifier = System.Text.RegularExpressions.Regex.Replace(identifier, "__+", "_");
            identifier = identifier.Trim('_');

            if (string.IsNullOrEmpty(identifier))
            {
                Debug.LogError($"Sanitization resulted in empty identifier for name: '{name}'");
                return "";
            }

            if (!System.CodeDom.Compiler.CodeGenerator.IsValidLanguageIndependentIdentifier(identifier))
            {
                Debug.LogError($"Sanitized identifier '{identifier}' for name '{name}' is not a valid C# identifier.");
                return "";
            }


            return identifier;
        }
    }
}
